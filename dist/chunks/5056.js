/*! For license information please see <unstable> */
"use strict";
(self.webpackChunkweb_appedashi = self.webpackChunkweb_appedashi || []).push([
    [5056], {
        94902: (t, e, i) => {
            var s = i(55253);
            e.DF = {
                prefix: s.prefix,
                iconName: s.iconName,
                icon: [s.width, s.height, s.aliases, s.unicode, s.svgPathData]
            }, e.G1 = e.DF, s.prefix, s.iconName, s.width, s.height, s.aliases, s.unicode, s.svgPathData, s.aliases
        },
        55253: (t, e) => {
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = "boxes-stacked",
                s = [62625, "boxes", "boxes-alt"],
                n = "f468",
                o = "M248 0L208 0c-26.5 0-48 21.5-48 48l0 112c0 35.3 28.7 64 64 64l128 0c35.3 0 64-28.7 64-64l0-112c0-26.5-21.5-48-48-48L328 0l0 80c0 8.8-7.2 16-16 16l-48 0c-8.8 0-16-7.2-16-16l0-80zM64 256c-35.3 0-64 28.7-64 64L0 448c0 35.3 28.7 64 64 64l160 0c35.3 0 64-28.7 64-64l0-128c0-35.3-28.7-64-64-64l-40 0 0 80c0 8.8-7.2 16-16 16l-48 0c-8.8 0-16-7.2-16-16l0-80-40 0zM352 512l160 0c35.3 0 64-28.7 64-64l0-128c0-35.3-28.7-64-64-64l-40 0 0 80c0 8.8-7.2 16-16 16l-48 0c-8.8 0-16-7.2-16-16l0-80-40 0c-15 0-28.8 5.1-39.7 13.8c4.9 10.4 7.7 22 7.7 34.2l0 160c0 12.2-2.8 23.8-7.7 34.2C323.2 506.9 337 512 352 512z";
            e.definition = {
                prefix: "fas",
                iconName: i,
                icon: [576, 512, s, n, o]
            }, e.faBoxesStacked = e.definition, e.prefix = "fas", e.iconName = i, e.width = 576, e.height = 512, e.ligatures = s, e.unicode = n, e.svgPathData = o, e.aliases = s
        },
        96914: (t, e) => {
            var i = "chart-line",
                s = ["line-chart"],
                n = "f201",
                o = "M64 64c0-17.7-14.3-32-32-32S0 46.3 0 64L0 400c0 44.2 35.8 80 80 80l400 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L80 416c-8.8 0-16-7.2-16-16L64 64zm406.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L320 210.7l-57.4-57.4c-12.5-12.5-32.8-12.5-45.3 0l-112 112c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L240 221.3l57.4 57.4c12.5 12.5 32.8 12.5 45.3 0l128-128z";
            e.DF = {
                prefix: "fas",
                iconName: i,
                icon: [512, 512, s, n, o]
            }, e.St = e.DF
        },
        41145: (t, e) => {
            var i = "chevron-down",
                s = [],
                n = "f078",
                o = "M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z";
            e.DF = {
                prefix: "fas",
                iconName: i,
                icon: [512, 512, s, n, o]
            }, e.pt = e.DF
        },
        62228: (t, e) => {
            var i = "chevron-up",
                s = [],
                n = "f077",
                o = "M233.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L256 173.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z";
            e.DF = {
                prefix: "fas",
                iconName: i,
                icon: [512, 512, s, n, o]
            }, e.mT = e.DF
        },
        97798: (t, e) => {
            var i = "ellipsis-vertical",
                s = ["ellipsis-v"],
                n = "f142",
                o = "M64 360a56 56 0 1 0 0 112 56 56 0 1 0 0-112zm0-160a56 56 0 1 0 0 112 56 56 0 1 0 0-112zM120 96A56 56 0 1 0 8 96a56 56 0 1 0 112 0z";
            e.DF = {
                prefix: "fas",
                iconName: i,
                icon: [128, 512, s, n, o]
            }, e.Uw = e.DF
        },
        38252: (t, e) => {
            var i = "grip-vertical",
                s = [],
                n = "f58e",
                o = "M40 352l48 0c22.1 0 40 17.9 40 40l0 48c0 22.1-17.9 40-40 40l-48 0c-22.1 0-40-17.9-40-40l0-48c0-22.1 17.9-40 40-40zm192 0l48 0c22.1 0 40 17.9 40 40l0 48c0 22.1-17.9 40-40 40l-48 0c-22.1 0-40-17.9-40-40l0-48c0-22.1 17.9-40 40-40zM40 320c-22.1 0-40-17.9-40-40l0-48c0-22.1 17.9-40 40-40l48 0c22.1 0 40 17.9 40 40l0 48c0 22.1-17.9 40-40 40l-48 0zM232 192l48 0c22.1 0 40 17.9 40 40l0 48c0 22.1-17.9 40-40 40l-48 0c-22.1 0-40-17.9-40-40l0-48c0-22.1 17.9-40 40-40zM40 160c-22.1 0-40-17.9-40-40L0 72C0 49.9 17.9 32 40 32l48 0c22.1 0 40 17.9 40 40l0 48c0 22.1-17.9 40-40 40l-48 0zM232 32l48 0c22.1 0 40 17.9 40 40l0 48c0 22.1-17.9 40-40 40l-48 0c-22.1 0-40-17.9-40-40l0-48c0-22.1 17.9-40 40-40z";
            e.DF = {
                prefix: "fas",
                iconName: i,
                icon: [320, 512, s, n, o]
            }, e.g$ = e.DF
        },
        2293: (t, e) => {
            var i = "receipt",
                s = [129534],
                n = "f543",
                o = "M14 2.2C22.5-1.7 32.5-.3 39.6 5.8L80 40.4 120.4 5.8c9-7.7 22.3-7.7 31.2 0L192 40.4 232.4 5.8c9-7.7 22.3-7.7 31.2 0L304 40.4 344.4 5.8c7.1-6.1 17.1-7.5 25.6-3.6s14 12.4 14 21.8l0 464c0 9.4-5.5 17.9-14 21.8s-18.5 2.5-25.6-3.6L304 471.6l-40.4 34.6c-9 7.7-22.3 7.7-31.2 0L192 471.6l-40.4 34.6c-9 7.7-22.3 7.7-31.2 0L80 471.6 39.6 506.2c-7.1 6.1-17.1 7.5-25.6 3.6S0 497.4 0 488L0 24C0 14.6 5.5 6.1 14 2.2zM96 144c-8.8 0-16 7.2-16 16s7.2 16 16 16l192 0c8.8 0 16-7.2 16-16s-7.2-16-16-16L96 144zM80 352c0 8.8 7.2 16 16 16l192 0c8.8 0 16-7.2 16-16s-7.2-16-16-16L96 336c-8.8 0-16 7.2-16 16zM96 240c-8.8 0-16 7.2-16 16s7.2 16 16 16l192 0c8.8 0 16-7.2 16-16s-7.2-16-16-16L96 240z";
            e.DF = {
                prefix: "fas",
                iconName: i,
                icon: [384, 512, s, n, o]
            }, e.dL = e.DF
        },
        62475: (t, e) => {
            var i = "sort-down",
                s = ["sort-desc"],
                n = "f0dd",
                o = "M182.6 470.6c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-9.2-9.2-11.9-22.9-6.9-34.9s16.6-19.8 29.6-19.8l256 0c12.9 0 24.6 7.8 29.6 19.8s2.2 25.7-6.9 34.9l-128 128z";
            e.DF = {
                prefix: "fas",
                iconName: i,
                icon: [320, 512, s, n, o]
            }, e.u9 = e.DF
        },
        96766: (t, e) => {
            var i = "sort-up",
                s = ["sort-asc"],
                n = "f0de",
                o = "M182.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-128 128c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8l256 0c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-128-128z";
            e.DF = {
                prefix: "fas",
                iconName: i,
                icon: [320, 512, s, n, o]
            }, e.fo = e.DF
        },
        68335: (t, e) => {
            var i = "store",
                s = [],
                n = "f54e",
                o = "M547.6 103.8L490.3 13.1C485.2 5 476.1 0 466.4 0L109.6 0C99.9 0 90.8 5 85.7 13.1L28.3 103.8c-29.6 46.8-3.4 111.9 51.9 119.4c4 .5 8.1 .8 12.1 .8c26.1 0 49.3-11.4 65.2-29c15.9 17.6 39.1 29 65.2 29c26.1 0 49.3-11.4 65.2-29c15.9 17.6 39.1 29 65.2 29c26.2 0 49.3-11.4 65.2-29c16 17.6 39.1 29 65.2 29c4.1 0 8.1-.3 12.1-.8c55.5-7.4 81.8-72.5 52.1-119.4zM499.7 254.9c0 0 0 0-.1 0c-5.3 .7-10.7 1.1-16.2 1.1c-12.4 0-24.3-1.9-35.4-5.3L448 384l-320 0 0-133.4c-11.2 3.5-23.2 5.4-35.6 5.4c-5.5 0-11-.4-16.3-1.1l-.1 0c-4.1-.6-8.1-1.3-12-2.3L64 384l0 64c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-64 0-131.4c-4 1-8 1.8-12.3 2.3z";
            e.DF = {
                prefix: "fas",
                iconName: i,
                icon: [576, 512, s, n, o]
            }, e.vJ = e.DF
        },
        34327: (t, e) => {
            var i = [127991],
                s = "f02b",
                n = "M0 80L0 229.5c0 17 6.7 33.3 18.7 45.3l176 176c25 25 65.5 25 90.5 0L418.7 317.3c25-25 25-65.5 0-90.5l-176-176c-12-12-28.3-18.7-45.3-18.7L48 32C21.5 32 0 53.5 0 80zm112 32a32 32 0 1 1 0 64 32 32 0 1 1 0-64z";
            e.DF = {
                prefix: "fas",
                iconName: "tag",
                icon: [448, 512, i, s, n]
            }, e.LE = e.DF
        },
        81116: (t, e) => {
            var i = "user-lock",
                s = [],
                n = "f502",
                o = "M224 256A128 128 0 1 0 224 0a128 128 0 1 0 0 256zm-45.7 48C79.8 304 0 383.8 0 482.3C0 498.7 13.3 512 29.7 512l362.8 0c-5.4-9.4-8.6-20.3-8.6-32l0-128c0-2.1 .1-4.2 .3-6.3c-31-26-71-41.7-114.6-41.7l-91.4 0zM528 240c17.7 0 32 14.3 32 32l0 48-64 0 0-48c0-17.7 14.3-32 32-32zm-80 32l0 48c-17.7 0-32 14.3-32 32l0 128c0 17.7 14.3 32 32 32l160 0c17.7 0 32-14.3 32-32l0-128c0-17.7-14.3-32-32-32l0-48c0-44.2-35.8-80-80-80s-80 35.8-80 80z";
            e.DF = {
                prefix: "fas",
                iconName: i,
                icon: [640, 512, s, n, o]
            }, e.FJ = e.DF
        },
        11298: (t, e) => {
            var i = "user-secret",
                s = [128373],
                n = "f21b",
                o = "M224 16c-6.7 0-10.8-2.8-15.5-6.1C201.9 5.4 194 0 176 0c-30.5 0-52 43.7-66 89.4C62.7 98.1 32 112.2 32 128c0 14.3 25 27.1 64.6 35.9c-.4 4-.6 8-.6 12.1c0 17 3.3 33.2 9.3 48l-59.9 0C38 224 32 230 32 237.4c0 1.7 .3 3.4 1 5l38.8 96.9C28.2 371.8 0 423.8 0 482.3C0 498.7 13.3 512 29.7 512l388.6 0c16.4 0 29.7-13.3 29.7-29.7c0-58.5-28.2-110.4-71.7-143L415 242.4c.6-1.6 1-3.3 1-5c0-7.4-6-13.4-13.4-13.4l-59.9 0c6-14.8 9.3-31 9.3-48c0-4.1-.2-8.1-.6-12.1C391 155.1 416 142.3 416 128c0-15.8-30.7-29.9-78-38.6C324 43.7 302.5 0 272 0c-18 0-25.9 5.4-32.5 9.9c-4.8 3.3-8.8 6.1-15.5 6.1zm56 208l-12.4 0c-16.5 0-31.1-10.6-36.3-26.2c-2.3-7-12.2-7-14.5 0c-5.2 15.6-19.9 26.2-36.3 26.2L168 224c-22.1 0-40-17.9-40-40l0-14.4c28.2 4.1 61 6.4 96 6.4s67.8-2.3 96-6.4l0 14.4c0 22.1-17.9 40-40 40zm-88 96l16 32L176 480 128 288l64 32zm128-32L272 480 240 352l16-32 64-32z";
            e.DF = {
                prefix: "fas",
                iconName: i,
                icon: [448, 512, s, n, o]
            }, e.BC = e.DF
        },
        57520: (t, e, i) => {
            var s = {};
            i.r(s), i.d(s, {
                afterMain: () => n.wX,
                afterRead: () => n.r5,
                afterWrite: () => n.MS,
                applyStyles: () => o.Z,
                arrow: () => r.Z,
                auto: () => n.d7,
                basePlacements: () => n.mv,
                beforeMain: () => n.XM,
                beforeRead: () => n.N7,
                beforeWrite: () => n.iv,
                bottom: () => n.I,
                clippingParents: () => n.zV,
                computeStyles: () => a.Z,
                createPopper: () => m.fi,
                createPopperBase: () => f.fi,
                createPopperLite: () => b,
                detectOverflow: () => g.Z,
                end: () => n.ut,
                eventListeners: () => l.Z,
                flip: () => c.Z,
                hide: () => h.Z,
                left: () => n.t$,
                main: () => n.DH,
                modifierPhases: () => n.xs,
                offset: () => d.Z,
                placements: () => n.Ct,
                popper: () => n.k5,
                popperGenerator: () => f.kZ,
                popperOffsets: () => u.Z,
                preventOverflow: () => _.Z,
                read: () => n.ij,
                reference: () => n.YP,
                right: () => n.F2,
                start: () => n.BL,
                top: () => n.we,
                variationPlacements: () => n.bw,
                viewport: () => n.Pj,
                write: () => n.cW
            });
            var n = i(87701),
                o = i(17824),
                r = i(66896),
                a = i(36531),
                l = i(82372),
                c = i(10696),
                h = i(19892),
                d = i(82122),
                u = i(77421),
                _ = i(48748),
                f = i(97796),
                g = i(66774),
                m = i(20804),
                p = [l.Z, u.Z, a.Z, o.Z],
                b = (0, f.kZ)({
                    defaultModifiers: p
                });
            const v = new Map,
                y = {
                    set(t, e, i) {
                        v.has(t) || v.set(t, new Map);
                        const s = v.get(t);
                        s.has(e) || 0 === s.size ? s.set(e, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`)
                    },
                    get: (t, e) => v.has(t) && v.get(t).get(e) || null,
                    remove(t, e) {
                        if (!v.has(t)) return;
                        const i = v.get(t);
                        i.delete(e), 0 === i.size && v.delete(t)
                    }
                },
                w = "transitionend",
                A = t => (t && window.CSS && window.CSS.escape && (t = t.replace(/#([^\s"#']+)/g, ((t, e) => `#${CSS.escape(e)}`))), t),
                C = t => {
                    t.dispatchEvent(new Event(w))
                },
                E = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType),
                T = t => E(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(A(t)) : null,
                k = t => {
                    if (!E(t) || 0 === t.getClientRects().length) return !1;
                    const e = "visible" === getComputedStyle(t).getPropertyValue("visibility"),
                        i = t.closest("details:not([open])");
                    if (!i) return e;
                    if (i !== t) {
                        const e = t.closest("summary");
                        if (e && e.parentNode !== i) return !1;
                        if (null === e) return !1
                    }
                    return e
                },
                L = t => !t || t.nodeType !== Node.ELEMENT_NODE || (!!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled"))),
                $ = t => {
                    if (!document.documentElement.attachShadow) return null;
                    if ("function" == typeof t.getRootNode) {
                        const e = t.getRootNode();
                        return e instanceof ShadowRoot ? e : null
                    }
                    return t instanceof ShadowRoot ? t : t.parentNode ? $(t.parentNode) : null
                },
                D = () => {},
                S = t => {
                    t.offsetHeight
                },
                N = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null,
                I = [],
                O = () => "rtl" === document.documentElement.dir,
                M = t => {
                    var e;
                    e = () => {
                        const e = N();
                        if (e) {
                            const i = t.NAME,
                                s = e.fn[i];
                            e.fn[i] = t.jQueryInterface, e.fn[i].Constructor = t, e.fn[i].noConflict = () => (e.fn[i] = s, t.jQueryInterface)
                        }
                    }, "loading" === document.readyState ? (I.length || document.addEventListener("DOMContentLoaded", (() => {
                        for (const t of I) t()
                    })), I.push(e)) : e()
                },
                x = (t, e = [], i = t) => "function" == typeof t ? t(...e) : i,
                P = (t, e, i = !0) => {
                    if (!i) return void x(t);
                    const s = (t => {
                        if (!t) return 0;
                        let {
                            transitionDuration: e,
                            transitionDelay: i
                        } = window.getComputedStyle(t);
                        const s = Number.parseFloat(e),
                            n = Number.parseFloat(i);
                        return s || n ? (e = e.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0
                    })(e) + 5;
                    let n = !1;
                    const o = ({
                        target: i
                    }) => {
                        i === e && (n = !0, e.removeEventListener(w, o), x(t))
                    };
                    e.addEventListener(w, o), setTimeout((() => {
                        n || C(e)
                    }), s)
                },
                F = (t, e, i, s) => {
                    const n = t.length;
                    let o = t.indexOf(e);
                    return -1 === o ? !i && s ? t[n - 1] : t[0] : (o += i ? 1 : -1, s && (o = (o + n) % n), t[Math.max(0, Math.min(o, n - 1))])
                },
                z = /[^.]*(?=\..*)\.|.*/,
                j = /\..*/,
                H = /::\d+$/,
                B = {};
            let W = 1;
            const q = {
                    mouseenter: "mouseover",
                    mouseleave: "mouseout"
                },
                R = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);

            function V(t, e) {
                return e && `${e}::${W++}` || t.uidEvent || W++
            }

            function K(t) {
                const e = V(t);
                return t.uidEvent = e, B[e] = B[e] || {}, B[e]
            }

            function Z(t, e, i = null) {
                return Object.values(t).find((t => t.callable === e && t.delegationSelector === i))
            }

            function Q(t, e, i) {
                const s = "string" == typeof e,
                    n = s ? i : e || i;
                let o = G(t);
                return R.has(o) || (o = t), [s, n, o]
            }

            function X(t, e, i, s, n) {
                if ("string" != typeof e || !t) return;
                let [o, r, a] = Q(e, i, s);
                if (e in q) {
                    const t = t => function(e) {
                        if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e)
                    };
                    r = t(r)
                }
                const l = K(t),
                    c = l[a] || (l[a] = {}),
                    h = Z(c, r, o ? i : null);
                if (h) return void(h.oneOff = h.oneOff && n);
                const d = V(r, e.replace(z, "")),
                    u = o ? function(t, e, i) {
                        return function s(n) {
                            const o = t.querySelectorAll(e);
                            for (let {
                                    target: r
                                } = n; r && r !== this; r = r.parentNode)
                                for (const a of o)
                                    if (a === r) return tt(n, {
                                        delegateTarget: r
                                    }), s.oneOff && J.off(t, n.type, e, i), i.apply(r, [n])
                        }
                    }(t, i, r) : function(t, e) {
                        return function i(s) {
                            return tt(s, {
                                delegateTarget: t
                            }), i.oneOff && J.off(t, s.type, e), e.apply(t, [s])
                        }
                    }(t, r);
                u.delegationSelector = o ? i : null, u.callable = r, u.oneOff = n, u.uidEvent = d, c[d] = u, t.addEventListener(a, u, o)
            }

            function Y(t, e, i, s, n) {
                const o = Z(e[i], s, n);
                o && (t.removeEventListener(i, o, Boolean(n)), delete e[i][o.uidEvent])
            }

            function U(t, e, i, s) {
                const n = e[i] || {};
                for (const [o, r] of Object.entries(n)) o.includes(s) && Y(t, e, i, r.callable, r.delegationSelector)
            }

            function G(t) {
                return t = t.replace(j, ""), q[t] || t
            }
            const J = {
                on(t, e, i, s) {
                    X(t, e, i, s, !1)
                },
                one(t, e, i, s) {
                    X(t, e, i, s, !0)
                },
                off(t, e, i, s) {
                    if ("string" != typeof e || !t) return;
                    const [n, o, r] = Q(e, i, s), a = r !== e, l = K(t), c = l[r] || {}, h = e.startsWith(".");
                    if (void 0 === o) {
                        if (h)
                            for (const i of Object.keys(l)) U(t, l, i, e.slice(1));
                        for (const [i, s] of Object.entries(c)) {
                            const n = i.replace(H, "");
                            a && !e.includes(n) || Y(t, l, r, s.callable, s.delegationSelector)
                        }
                    } else {
                        if (!Object.keys(c).length) return;
                        Y(t, l, r, o, n ? i : null)
                    }
                },
                trigger(t, e, i) {
                    if ("string" != typeof e || !t) return null;
                    const s = N();
                    let n = null,
                        o = !0,
                        r = !0,
                        a = !1;
                    e !== G(e) && s && (n = s.Event(e, i), s(t).trigger(n), o = !n.isPropagationStopped(), r = !n.isImmediatePropagationStopped(), a = n.isDefaultPrevented());
                    const l = tt(new Event(e, {
                        bubbles: o,
                        cancelable: !0
                    }), i);
                    return a && l.preventDefault(), r && t.dispatchEvent(l), l.defaultPrevented && n && n.preventDefault(), l
                }
            };

            function tt(t, e = {}) {
                for (const [i, s] of Object.entries(e)) try {
                    t[i] = s
                } catch (e) {
                    Object.defineProperty(t, i, {
                        configurable: !0,
                        get: () => s
                    })
                }
                return t
            }

            function et(t) {
                if ("true" === t) return !0;
                if ("false" === t) return !1;
                if (t === Number(t).toString()) return Number(t);
                if ("" === t || "null" === t) return null;
                if ("string" != typeof t) return t;
                try {
                    return JSON.parse(decodeURIComponent(t))
                } catch (e) {
                    return t
                }
            }

            function it(t) {
                return t.replace(/[A-Z]/g, (t => `-${t.toLowerCase()}`))
            }
            const st = {
                setDataAttribute(t, e, i) {
                    t.setAttribute(`data-bs-${it(e)}`, i)
                },
                removeDataAttribute(t, e) {
                    t.removeAttribute(`data-bs-${it(e)}`)
                },
                getDataAttributes(t) {
                    if (!t) return {};
                    const e = {},
                        i = Object.keys(t.dataset).filter((t => t.startsWith("bs") && !t.startsWith("bsConfig")));
                    for (const s of i) {
                        let i = s.replace(/^bs/, "");
                        i = i.charAt(0).toLowerCase() + i.slice(1, i.length), e[i] = et(t.dataset[s])
                    }
                    return e
                },
                getDataAttribute: (t, e) => et(t.getAttribute(`data-bs-${it(e)}`))
            };
            class nt {
                static get Default() {
                    return {}
                }
                static get DefaultType() {
                    return {}
                }
                static get NAME() {
                    throw new Error('You have to implement the static method "NAME", for each component!')
                }
                _getConfig(t) {
                    return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
                }
                _configAfterMerge(t) {
                    return t
                }
                _mergeConfigObj(t, e) {
                    const i = E(e) ? st.getDataAttribute(e, "config") : {};
                    return {
                        ...this.constructor.Default,
                        ..."object" == typeof i ? i : {},
                        ...E(e) ? st.getDataAttributes(e) : {},
                        ..."object" == typeof t ? t : {}
                    }
                }
                _typeCheckConfig(t, e = this.constructor.DefaultType) {
                    for (const [s, n] of Object.entries(e)) {
                        const e = t[s],
                            o = E(e) ? "element" : null == (i = e) ? `${i}` : Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase();
                        if (!new RegExp(n).test(o)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${s}" provided type "${o}" but expected type "${n}".`)
                    }
                    var i
                }
            }
            class ot extends nt {
                constructor(t, e) {
                    super(), (t = T(t)) && (this._element = t, this._config = this._getConfig(e), y.set(this._element, this.constructor.DATA_KEY, this))
                }
                dispose() {
                    y.remove(this._element, this.constructor.DATA_KEY), J.off(this._element, this.constructor.EVENT_KEY);
                    for (const t of Object.getOwnPropertyNames(this)) this[t] = null
                }
                _queueCallback(t, e, i = !0) {
                    P(t, e, i)
                }
                _getConfig(t) {
                    return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
                }
                static getInstance(t) {
                    return y.get(T(t), this.DATA_KEY)
                }
                static getOrCreateInstance(t, e = {}) {
                    return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
                }
                static get VERSION() {
                    return "5.3.2"
                }
                static get DATA_KEY() {
                    return `bs.${this.NAME}`
                }
                static get EVENT_KEY() {
                    return `.${this.DATA_KEY}`
                }
                static eventName(t) {
                    return `${t}${this.EVENT_KEY}`
                }
            }
            const rt = t => {
                    let e = t.getAttribute("data-bs-target");
                    if (!e || "#" === e) {
                        let i = t.getAttribute("href");
                        if (!i || !i.includes("#") && !i.startsWith(".")) return null;
                        i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`), e = i && "#" !== i ? A(i.trim()) : null
                    }
                    return e
                },
                at = {
                    find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)),
                    findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t),
                    children: (t, e) => [].concat(...t.children).filter((t => t.matches(e))),
                    parents(t, e) {
                        const i = [];
                        let s = t.parentNode.closest(e);
                        for (; s;) i.push(s), s = s.parentNode.closest(e);
                        return i
                    },
                    prev(t, e) {
                        let i = t.previousElementSibling;
                        for (; i;) {
                            if (i.matches(e)) return [i];
                            i = i.previousElementSibling
                        }
                        return []
                    },
                    next(t, e) {
                        let i = t.nextElementSibling;
                        for (; i;) {
                            if (i.matches(e)) return [i];
                            i = i.nextElementSibling
                        }
                        return []
                    },
                    focusableChildren(t) {
                        const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((t => `${t}:not([tabindex^="-"])`)).join(",");
                        return this.find(e, t).filter((t => !L(t) && k(t)))
                    },
                    getSelectorFromElement(t) {
                        const e = rt(t);
                        return e && at.findOne(e) ? e : null
                    },
                    getElementFromSelector(t) {
                        const e = rt(t);
                        return e ? at.findOne(e) : null
                    },
                    getMultipleElementsFromSelector(t) {
                        const e = rt(t);
                        return e ? at.find(e) : []
                    }
                },
                lt = (t, e = "hide") => {
                    const i = `click.dismiss${t.EVENT_KEY}`,
                        s = t.NAME;
                    J.on(document, i, `[data-bs-dismiss="${s}"]`, (function(i) {
                        if (["A", "AREA"].includes(this.tagName) && i.preventDefault(), L(this)) return;
                        const n = at.getElementFromSelector(this) || this.closest(`.${s}`);
                        t.getOrCreateInstance(n)[e]()
                    }))
                },
                ct = ".bs.alert",
                ht = `close${ct}`,
                dt = `closed${ct}`;
            class ut extends ot {
                static get NAME() {
                    return "alert"
                }
                close() {
                    if (J.trigger(this._element, ht).defaultPrevented) return;
                    this._element.classList.remove("show");
                    const t = this._element.classList.contains("fade");
                    this._queueCallback((() => this._destroyElement()), this._element, t)
                }
                _destroyElement() {
                    this._element.remove(), J.trigger(this._element, dt), this.dispose()
                }
                static jQueryInterface(t) {
                    return this.each((function() {
                        const e = ut.getOrCreateInstance(this);
                        if ("string" == typeof t) {
                            if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                            e[t](this)
                        }
                    }))
                }
            }
            lt(ut, "close"), M(ut);
            const _t = '[data-bs-toggle="button"]';
            class ft extends ot {
                static get NAME() {
                    return "button"
                }
                toggle() {
                    this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
                }
                static jQueryInterface(t) {
                    return this.each((function() {
                        const e = ft.getOrCreateInstance(this);
                        "toggle" === t && e[t]()
                    }))
                }
            }
            J.on(document, "click.bs.button.data-api", _t, (t => {
                t.preventDefault();
                const e = t.target.closest(_t);
                ft.getOrCreateInstance(e).toggle()
            })), M(ft);
            const gt = ".bs.swipe",
                mt = `touchstart${gt}`,
                pt = `touchmove${gt}`,
                bt = `touchend${gt}`,
                vt = `pointerdown${gt}`,
                yt = `pointerup${gt}`,
                wt = {
                    endCallback: null,
                    leftCallback: null,
                    rightCallback: null
                },
                At = {
                    endCallback: "(function|null)",
                    leftCallback: "(function|null)",
                    rightCallback: "(function|null)"
                };
            class Ct extends nt {
                constructor(t, e) {
                    super(), this._element = t, t && Ct.isSupported() && (this._config = this._getConfig(e), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents())
                }
                static get Default() {
                    return wt
                }
                static get DefaultType() {
                    return At
                }
                static get NAME() {
                    return "swipe"
                }
                dispose() {
                    J.off(this._element, gt)
                }
                _start(t) {
                    this._supportPointerEvents ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX) : this._deltaX = t.touches[0].clientX
                }
                _end(t) {
                    this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), x(this._config.endCallback)
                }
                _move(t) {
                    this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX
                }
                _handleSwipe() {
                    const t = Math.abs(this._deltaX);
                    if (t <= 40) return;
                    const e = t / this._deltaX;
                    this._deltaX = 0, e && x(e > 0 ? this._config.rightCallback : this._config.leftCallback)
                }
                _initEvents() {
                    this._supportPointerEvents ? (J.on(this._element, vt, (t => this._start(t))), J.on(this._element, yt, (t => this._end(t))), this._element.classList.add("pointer-event")) : (J.on(this._element, mt, (t => this._start(t))), J.on(this._element, pt, (t => this._move(t))), J.on(this._element, bt, (t => this._end(t))))
                }
                _eventIsPointerPenTouch(t) {
                    return this._supportPointerEvents && ("pen" === t.pointerType || "touch" === t.pointerType)
                }
                static isSupported() {
                    return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0
                }
            }
            const Et = ".bs.carousel",
                Tt = ".data-api",
                kt = "next",
                Lt = "prev",
                $t = "left",
                Dt = "right",
                St = `slide${Et}`,
                Nt = `slid${Et}`,
                It = `keydown${Et}`,
                Ot = `mouseenter${Et}`,
                Mt = `mouseleave${Et}`,
                xt = `dragstart${Et}`,
                Pt = `load${Et}${Tt}`,
                Ft = `click${Et}${Tt}`,
                zt = "carousel",
                jt = "active",
                Ht = ".active",
                Bt = ".carousel-item",
                Wt = Ht + Bt,
                qt = {
                    ArrowLeft: Dt,
                    ArrowRight: $t
                },
                Rt = {
                    interval: 5e3,
                    keyboard: !0,
                    pause: "hover",
                    ride: !1,
                    touch: !0,
                    wrap: !0
                },
                Vt = {
                    interval: "(number|boolean)",
                    keyboard: "boolean",
                    pause: "(string|boolean)",
                    ride: "(boolean|string)",
                    touch: "boolean",
                    wrap: "boolean"
                };
            class Kt extends ot {
                constructor(t, e) {
                    super(t, e), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = at.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === zt && this.cycle()
                }
                static get Default() {
                    return Rt
                }
                static get DefaultType() {
                    return Vt
                }
                static get NAME() {
                    return "carousel"
                }
                next() {
                    this._slide(kt)
                }
                nextWhenVisible() {
                    !document.hidden && k(this._element) && this.next()
                }
                prev() {
                    this._slide(Lt)
                }
                pause() {
                    this._isSliding && C(this._element), this._clearInterval()
                }
                cycle() {
                    this._clearInterval(), this._updateInterval(), this._interval = setInterval((() => this.nextWhenVisible()), this._config.interval)
                }
                _maybeEnableCycle() {
                    this._config.ride && (this._isSliding ? J.one(this._element, Nt, (() => this.cycle())) : this.cycle())
                }
                to(t) {
                    const e = this._getItems();
                    if (t > e.length - 1 || t < 0) return;
                    if (this._isSliding) return void J.one(this._element, Nt, (() => this.to(t)));
                    const i = this._getItemIndex(this._getActive());
                    if (i === t) return;
                    const s = t > i ? kt : Lt;
                    this._slide(s, e[t])
                }
                dispose() {
                    this._swipeHelper && this._swipeHelper.dispose(), super.dispose()
                }
                _configAfterMerge(t) {
                    return t.defaultInterval = t.interval, t
                }
                _addEventListeners() {
                    this._config.keyboard && J.on(this._element, It, (t => this._keydown(t))), "hover" === this._config.pause && (J.on(this._element, Ot, (() => this.pause())), J.on(this._element, Mt, (() => this._maybeEnableCycle()))), this._config.touch && Ct.isSupported() && this._addTouchEventListeners()
                }
                _addTouchEventListeners() {
                    for (const t of at.find(".carousel-item img", this._element)) J.on(t, xt, (t => t.preventDefault()));
                    const t = {
                        leftCallback: () => this._slide(this._directionToOrder($t)),
                        rightCallback: () => this._slide(this._directionToOrder(Dt)),
                        endCallback: () => {
                            "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout((() => this._maybeEnableCycle()), 500 + this._config.interval))
                        }
                    };
                    this._swipeHelper = new Ct(this._element, t)
                }
                _keydown(t) {
                    if (/input|textarea/i.test(t.target.tagName)) return;
                    const e = qt[t.key];
                    e && (t.preventDefault(), this._slide(this._directionToOrder(e)))
                }
                _getItemIndex(t) {
                    return this._getItems().indexOf(t)
                }
                _setActiveIndicatorElement(t) {
                    if (!this._indicatorsElement) return;
                    const e = at.findOne(Ht, this._indicatorsElement);
                    e.classList.remove(jt), e.removeAttribute("aria-current");
                    const i = at.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement);
                    i && (i.classList.add(jt), i.setAttribute("aria-current", "true"))
                }
                _updateInterval() {
                    const t = this._activeElement || this._getActive();
                    if (!t) return;
                    const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10);
                    this._config.interval = e || this._config.defaultInterval
                }
                _slide(t, e = null) {
                    if (this._isSliding) return;
                    const i = this._getActive(),
                        s = t === kt,
                        n = e || F(this._getItems(), i, s, this._config.wrap);
                    if (n === i) return;
                    const o = this._getItemIndex(n),
                        r = e => J.trigger(this._element, e, {
                            relatedTarget: n,
                            direction: this._orderToDirection(t),
                            from: this._getItemIndex(i),
                            to: o
                        });
                    if (r(St).defaultPrevented) return;
                    if (!i || !n) return;
                    const a = Boolean(this._interval);
                    this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = n;
                    const l = s ? "carousel-item-start" : "carousel-item-end",
                        c = s ? "carousel-item-next" : "carousel-item-prev";
                    n.classList.add(c), S(n), i.classList.add(l), n.classList.add(l);
                    this._queueCallback((() => {
                        n.classList.remove(l, c), n.classList.add(jt), i.classList.remove(jt, c, l), this._isSliding = !1, r(Nt)
                    }), i, this._isAnimated()), a && this.cycle()
                }
                _isAnimated() {
                    return this._element.classList.contains("slide")
                }
                _getActive() {
                    return at.findOne(Wt, this._element)
                }
                _getItems() {
                    return at.find(Bt, this._element)
                }
                _clearInterval() {
                    this._interval && (clearInterval(this._interval), this._interval = null)
                }
                _directionToOrder(t) {
                    return O() ? t === $t ? Lt : kt : t === $t ? kt : Lt
                }
                _orderToDirection(t) {
                    return O() ? t === Lt ? $t : Dt : t === Lt ? Dt : $t
                }
                static jQueryInterface(t) {
                    return this.each((function() {
                        const e = Kt.getOrCreateInstance(this, t);
                        if ("number" != typeof t) {
                            if ("string" == typeof t) {
                                if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                                e[t]()
                            }
                        } else e.to(t)
                    }))
                }
            }
            J.on(document, Ft, "[data-bs-slide], [data-bs-slide-to]", (function(t) {
                const e = at.getElementFromSelector(this);
                if (!e || !e.classList.contains(zt)) return;
                t.preventDefault();
                const i = Kt.getOrCreateInstance(e),
                    s = this.getAttribute("data-bs-slide-to");
                return s ? (i.to(s), void i._maybeEnableCycle()) : "next" === st.getDataAttribute(this, "slide") ? (i.next(), void i._maybeEnableCycle()) : (i.prev(), void i._maybeEnableCycle())
            })), J.on(window, Pt, (() => {
                const t = at.find('[data-bs-ride="carousel"]');
                for (const e of t) Kt.getOrCreateInstance(e)
            })), M(Kt);
            const Zt = ".bs.collapse",
                Qt = `show${Zt}`,
                Xt = `shown${Zt}`,
                Yt = `hide${Zt}`,
                Ut = `hidden${Zt}`,
                Gt = `click${Zt}.data-api`,
                Jt = "show",
                te = "collapse",
                ee = "collapsing",
                ie = `:scope .${te} .${te}`,
                se = '[data-bs-toggle="collapse"]',
                ne = {
                    parent: null,
                    toggle: !0
                },
                oe = {
                    parent: "(null|element)",
                    toggle: "boolean"
                };
            class re extends ot {
                constructor(t, e) {
                    super(t, e), this._isTransitioning = !1, this._triggerArray = [];
                    const i = at.find(se);
                    for (const t of i) {
                        const e = at.getSelectorFromElement(t),
                            i = at.find(e).filter((t => t === this._element));
                        null !== e && i.length && this._triggerArray.push(t)
                    }
                    this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle()
                }
                static get Default() {
                    return ne
                }
                static get DefaultType() {
                    return oe
                }
                static get NAME() {
                    return "collapse"
                }
                toggle() {
                    this._isShown() ? this.hide() : this.show()
                }
                show() {
                    if (this._isTransitioning || this._isShown()) return;
                    let t = [];
                    if (this._config.parent && (t = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((t => t !== this._element)).map((t => re.getOrCreateInstance(t, {
                            toggle: !1
                        })))), t.length && t[0]._isTransitioning) return;
                    if (J.trigger(this._element, Qt).defaultPrevented) return;
                    for (const e of t) e.hide();
                    const e = this._getDimension();
                    this._element.classList.remove(te), this._element.classList.add(ee), this._element.style[e] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
                    const i = `scroll${e[0].toUpperCase()+e.slice(1)}`;
                    this._queueCallback((() => {
                        this._isTransitioning = !1, this._element.classList.remove(ee), this._element.classList.add(te, Jt), this._element.style[e] = "", J.trigger(this._element, Xt)
                    }), this._element, !0), this._element.style[e] = `${this._element[i]}px`
                }
                hide() {
                    if (this._isTransitioning || !this._isShown()) return;
                    if (J.trigger(this._element, Yt).defaultPrevented) return;
                    const t = this._getDimension();
                    this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, S(this._element), this._element.classList.add(ee), this._element.classList.remove(te, Jt);
                    for (const t of this._triggerArray) {
                        const e = at.getElementFromSelector(t);
                        e && !this._isShown(e) && this._addAriaAndCollapsedClass([t], !1)
                    }
                    this._isTransitioning = !0;
                    this._element.style[t] = "", this._queueCallback((() => {
                        this._isTransitioning = !1, this._element.classList.remove(ee), this._element.classList.add(te), J.trigger(this._element, Ut)
                    }), this._element, !0)
                }
                _isShown(t = this._element) {
                    return t.classList.contains(Jt)
                }
                _configAfterMerge(t) {
                    return t.toggle = Boolean(t.toggle), t.parent = T(t.parent), t
                }
                _getDimension() {
                    return this._element.classList.contains("collapse-horizontal") ? "width" : "height"
                }
                _initializeChildren() {
                    if (!this._config.parent) return;
                    const t = this._getFirstLevelChildren(se);
                    for (const e of t) {
                        const t = at.getElementFromSelector(e);
                        t && this._addAriaAndCollapsedClass([e], this._isShown(t))
                    }
                }
                _getFirstLevelChildren(t) {
                    const e = at.find(ie, this._config.parent);
                    return at.find(t, this._config.parent).filter((t => !e.includes(t)))
                }
                _addAriaAndCollapsedClass(t, e) {
                    if (t.length)
                        for (const i of t) i.classList.toggle("collapsed", !e), i.setAttribute("aria-expanded", e)
                }
                static jQueryInterface(t) {
                    const e = {};
                    return "string" == typeof t && /show|hide/.test(t) && (e.toggle = !1), this.each((function() {
                        const i = re.getOrCreateInstance(this, e);
                        if ("string" == typeof t) {
                            if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
                            i[t]()
                        }
                    }))
                }
            }
            J.on(document, Gt, se, (function(t) {
                ("A" === t.target.tagName || t.delegateTarget && "A" === t.delegateTarget.tagName) && t.preventDefault();
                for (const t of at.getMultipleElementsFromSelector(this)) re.getOrCreateInstance(t, {
                    toggle: !1
                }).toggle()
            })), M(re);
            const ae = "dropdown",
                le = ".bs.dropdown",
                ce = ".data-api",
                he = "ArrowUp",
                de = "ArrowDown",
                ue = `hide${le}`,
                _e = `hidden${le}`,
                fe = `show${le}`,
                ge = `shown${le}`,
                me = `click${le}${ce}`,
                pe = `keydown${le}${ce}`,
                be = `keyup${le}${ce}`,
                ve = "show",
                ye = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)',
                we = `${ye}.${ve}`,
                Ae = ".dropdown-menu",
                Ce = O() ? "top-end" : "top-start",
                Ee = O() ? "top-start" : "top-end",
                Te = O() ? "bottom-end" : "bottom-start",
                ke = O() ? "bottom-start" : "bottom-end",
                Le = O() ? "left-start" : "right-start",
                $e = O() ? "right-start" : "left-start",
                De = {
                    autoClose: !0,
                    boundary: "clippingParents",
                    display: "dynamic",
                    offset: [0, 2],
                    popperConfig: null,
                    reference: "toggle"
                },
                Se = {
                    autoClose: "(boolean|string)",
                    boundary: "(string|element)",
                    display: "string",
                    offset: "(array|string|function)",
                    popperConfig: "(null|object|function)",
                    reference: "(string|element|object)"
                };
            class Ne extends ot {
                constructor(t, e) {
                    super(t, e), this._popper = null, this._parent = this._element.parentNode, this._menu = at.next(this._element, Ae)[0] || at.prev(this._element, Ae)[0] || at.findOne(Ae, this._parent), this._inNavbar = this._detectNavbar()
                }
                static get Default() {
                    return De
                }
                static get DefaultType() {
                    return Se
                }
                static get NAME() {
                    return ae
                }
                toggle() {
                    return this._isShown() ? this.hide() : this.show()
                }
                show() {
                    if (L(this._element) || this._isShown()) return;
                    const t = {
                        relatedTarget: this._element
                    };
                    if (!J.trigger(this._element, fe, t).defaultPrevented) {
                        if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav"))
                            for (const t of [].concat(...document.body.children)) J.on(t, "mouseover", D);
                        this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(ve), this._element.classList.add(ve), J.trigger(this._element, ge, t)
                    }
                }
                hide() {
                    if (L(this._element) || !this._isShown()) return;
                    const t = {
                        relatedTarget: this._element
                    };
                    this._completeHide(t)
                }
                dispose() {
                    this._popper && this._popper.destroy(), super.dispose()
                }
                update() {
                    this._inNavbar = this._detectNavbar(), this._popper && this._popper.update()
                }
                _completeHide(t) {
                    if (!J.trigger(this._element, ue, t).defaultPrevented) {
                        if ("ontouchstart" in document.documentElement)
                            for (const t of [].concat(...document.body.children)) J.off(t, "mouseover", D);
                        this._popper && this._popper.destroy(), this._menu.classList.remove(ve), this._element.classList.remove(ve), this._element.setAttribute("aria-expanded", "false"), st.removeDataAttribute(this._menu, "popper"), J.trigger(this._element, _e, t)
                    }
                }
                _getConfig(t) {
                    if ("object" == typeof(t = super._getConfig(t)).reference && !E(t.reference) && "function" != typeof t.reference.getBoundingClientRect) throw new TypeError(`${ae.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
                    return t
                }
                _createPopper() {
                    if (void 0 === s) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
                    let t = this._element;
                    "parent" === this._config.reference ? t = this._parent : E(this._config.reference) ? t = T(this._config.reference) : "object" == typeof this._config.reference && (t = this._config.reference);
                    const e = this._getPopperConfig();
                    this._popper = m.fi(t, this._menu, e)
                }
                _isShown() {
                    return this._menu.classList.contains(ve)
                }
                _getPlacement() {
                    const t = this._parent;
                    if (t.classList.contains("dropend")) return Le;
                    if (t.classList.contains("dropstart")) return $e;
                    if (t.classList.contains("dropup-center")) return "top";
                    if (t.classList.contains("dropdown-center")) return "bottom";
                    const e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
                    return t.classList.contains("dropup") ? e ? Ee : Ce : e ? ke : Te
                }
                _detectNavbar() {
                    return null !== this._element.closest(".navbar")
                }
                _getOffset() {
                    const {
                        offset: t
                    } = this._config;
                    return "string" == typeof t ? t.split(",").map((t => Number.parseInt(t, 10))) : "function" == typeof t ? e => t(e, this._element) : t
                }
                _getPopperConfig() {
                    const t = {
                        placement: this._getPlacement(),
                        modifiers: [{
                            name: "preventOverflow",
                            options: {
                                boundary: this._config.boundary
                            }
                        }, {
                            name: "offset",
                            options: {
                                offset: this._getOffset()
                            }
                        }]
                    };
                    return (this._inNavbar || "static" === this._config.display) && (st.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [{
                        name: "applyStyles",
                        enabled: !1
                    }]), {
                        ...t,
                        ...x(this._config.popperConfig, [t])
                    }
                }
                _selectMenuItem({
                    key: t,
                    target: e
                }) {
                    const i = at.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter((t => k(t)));
                    i.length && F(i, e, t === de, !i.includes(e)).focus()
                }
                static jQueryInterface(t) {
                    return this.each((function() {
                        const e = Ne.getOrCreateInstance(this, t);
                        if ("string" == typeof t) {
                            if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                            e[t]()
                        }
                    }))
                }
                static clearMenus(t) {
                    if (2 === t.button || "keyup" === t.type && "Tab" !== t.key) return;
                    const e = at.find(we);
                    for (const i of e) {
                        const e = Ne.getInstance(i);
                        if (!e || !1 === e._config.autoClose) continue;
                        const s = t.composedPath(),
                            n = s.includes(e._menu);
                        if (s.includes(e._element) || "inside" === e._config.autoClose && !n || "outside" === e._config.autoClose && n) continue;
                        if (e._menu.contains(t.target) && ("keyup" === t.type && "Tab" === t.key || /input|select|option|textarea|form/i.test(t.target.tagName))) continue;
                        const o = {
                            relatedTarget: e._element
                        };
                        "click" === t.type && (o.clickEvent = t), e._completeHide(o)
                    }
                }
                static dataApiKeydownHandler(t) {
                    const e = /input|textarea/i.test(t.target.tagName),
                        i = "Escape" === t.key,
                        s = [he, de].includes(t.key);
                    if (!s && !i) return;
                    if (e && !i) return;
                    t.preventDefault();
                    const n = this.matches(ye) ? this : at.prev(this, ye)[0] || at.next(this, ye)[0] || at.findOne(ye, t.delegateTarget.parentNode),
                        o = Ne.getOrCreateInstance(n);
                    if (s) return t.stopPropagation(), o.show(), void o._selectMenuItem(t);
                    o._isShown() && (t.stopPropagation(), o.hide(), n.focus())
                }
            }
            J.on(document, pe, ye, Ne.dataApiKeydownHandler), J.on(document, pe, Ae, Ne.dataApiKeydownHandler), J.on(document, me, Ne.clearMenus), J.on(document, be, Ne.clearMenus), J.on(document, me, ye, (function(t) {
                t.preventDefault(), Ne.getOrCreateInstance(this).toggle()
            })), M(Ne);
            const Ie = "backdrop",
                Oe = "show",
                Me = `mousedown.bs.${Ie}`,
                xe = {
                    className: "modal-backdrop",
                    clickCallback: null,
                    isAnimated: !1,
                    isVisible: !0,
                    rootElement: "body"
                },
                Pe = {
                    className: "string",
                    clickCallback: "(function|null)",
                    isAnimated: "boolean",
                    isVisible: "boolean",
                    rootElement: "(element|string)"
                };
            class Fe extends nt {
                constructor(t) {
                    super(), this._config = this._getConfig(t), this._isAppended = !1, this._element = null
                }
                static get Default() {
                    return xe
                }
                static get DefaultType() {
                    return Pe
                }
                static get NAME() {
                    return Ie
                }
                show(t) {
                    if (!this._config.isVisible) return void x(t);
                    this._append();
                    const e = this._getElement();
                    this._config.isAnimated && S(e), e.classList.add(Oe), this._emulateAnimation((() => {
                        x(t)
                    }))
                }
                hide(t) {
                    this._config.isVisible ? (this._getElement().classList.remove(Oe), this._emulateAnimation((() => {
                        this.dispose(), x(t)
                    }))) : x(t)
                }
                dispose() {
                    this._isAppended && (J.off(this._element, Me), this._element.remove(), this._isAppended = !1)
                }
                _getElement() {
                    if (!this._element) {
                        const t = document.createElement("div");
                        t.className = this._config.className, this._config.isAnimated && t.classList.add("fade"), this._element = t
                    }
                    return this._element
                }
                _configAfterMerge(t) {
                    return t.rootElement = T(t.rootElement), t
                }
                _append() {
                    if (this._isAppended) return;
                    const t = this._getElement();
                    this._config.rootElement.append(t), J.on(t, Me, (() => {
                        x(this._config.clickCallback)
                    })), this._isAppended = !0
                }
                _emulateAnimation(t) {
                    P(t, this._getElement(), this._config.isAnimated)
                }
            }
            const ze = ".bs.focustrap",
                je = `focusin${ze}`,
                He = `keydown.tab${ze}`,
                Be = "backward",
                We = {
                    autofocus: !0,
                    trapElement: null
                },
                qe = {
                    autofocus: "boolean",
                    trapElement: "element"
                };
            class Re extends nt {
                constructor(t) {
                    super(), this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null
                }
                static get Default() {
                    return We
                }
                static get DefaultType() {
                    return qe
                }
                static get NAME() {
                    return "focustrap"
                }
                activate() {
                    this._isActive || (this._config.autofocus && this._config.trapElement.focus(), J.off(document, ze), J.on(document, je, (t => this._handleFocusin(t))), J.on(document, He, (t => this._handleKeydown(t))), this._isActive = !0)
                }
                deactivate() {
                    this._isActive && (this._isActive = !1, J.off(document, ze))
                }
                _handleFocusin(t) {
                    const {
                        trapElement: e
                    } = this._config;
                    if (t.target === document || t.target === e || e.contains(t.target)) return;
                    const i = at.focusableChildren(e);
                    0 === i.length ? e.focus() : this._lastTabNavDirection === Be ? i[i.length - 1].focus() : i[0].focus()
                }
                _handleKeydown(t) {
                    "Tab" === t.key && (this._lastTabNavDirection = t.shiftKey ? Be : "forward")
                }
            }
            const Ve = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
                Ke = ".sticky-top",
                Ze = "padding-right",
                Qe = "margin-right";
            class Xe {
                constructor() {
                    this._element = document.body
                }
                getWidth() {
                    const t = document.documentElement.clientWidth;
                    return Math.abs(window.innerWidth - t)
                }
                hide() {
                    const t = this.getWidth();
                    this._disableOverFlow(), this._setElementAttributes(this._element, Ze, (e => e + t)), this._setElementAttributes(Ve, Ze, (e => e + t)), this._setElementAttributes(Ke, Qe, (e => e - t))
                }
                reset() {
                    this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, Ze), this._resetElementAttributes(Ve, Ze), this._resetElementAttributes(Ke, Qe)
                }
                isOverflowing() {
                    return this.getWidth() > 0
                }
                _disableOverFlow() {
                    this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden"
                }
                _setElementAttributes(t, e, i) {
                    const s = this.getWidth();
                    this._applyManipulationCallback(t, (t => {
                        if (t !== this._element && window.innerWidth > t.clientWidth + s) return;
                        this._saveInitialAttribute(t, e);
                        const n = window.getComputedStyle(t).getPropertyValue(e);
                        t.style.setProperty(e, `${i(Number.parseFloat(n))}px`)
                    }))
                }
                _saveInitialAttribute(t, e) {
                    const i = t.style.getPropertyValue(e);
                    i && st.setDataAttribute(t, e, i)
                }
                _resetElementAttributes(t, e) {
                    this._applyManipulationCallback(t, (t => {
                        const i = st.getDataAttribute(t, e);
                        null !== i ? (st.removeDataAttribute(t, e), t.style.setProperty(e, i)) : t.style.removeProperty(e)
                    }))
                }
                _applyManipulationCallback(t, e) {
                    if (E(t)) e(t);
                    else
                        for (const i of at.find(t, this._element)) e(i)
                }
            }
            const Ye = ".bs.modal",
                Ue = `hide${Ye}`,
                Ge = `hidePrevented${Ye}`,
                Je = `hidden${Ye}`,
                ti = `show${Ye}`,
                ei = `shown${Ye}`,
                ii = `resize${Ye}`,
                si = `click.dismiss${Ye}`,
                ni = `mousedown.dismiss${Ye}`,
                oi = `keydown.dismiss${Ye}`,
                ri = `click${Ye}.data-api`,
                ai = "modal-open",
                li = "show",
                ci = "modal-static",
                hi = {
                    backdrop: !0,
                    focus: !0,
                    keyboard: !0
                },
                di = {
                    backdrop: "(boolean|string)",
                    focus: "boolean",
                    keyboard: "boolean"
                };
            class ui extends ot {
                constructor(t, e) {
                    super(t, e), this._dialog = at.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new Xe, this._addEventListeners()
                }
                static get Default() {
                    return hi
                }
                static get DefaultType() {
                    return di
                }
                static get NAME() {
                    return "modal"
                }
                toggle(t) {
                    return this._isShown ? this.hide() : this.show(t)
                }
                show(t) {
                    if (this._isShown || this._isTransitioning) return;
                    J.trigger(this._element, ti, {
                        relatedTarget: t
                    }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(ai), this._adjustDialog(), this._backdrop.show((() => this._showElement(t))))
                }
                hide() {
                    if (!this._isShown || this._isTransitioning) return;
                    J.trigger(this._element, Ue).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(li), this._queueCallback((() => this._hideModal()), this._element, this._isAnimated()))
                }
                dispose() {
                    J.off(window, Ye), J.off(this._dialog, Ye), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
                }
                handleUpdate() {
                    this._adjustDialog()
                }
                _initializeBackDrop() {
                    return new Fe({
                        isVisible: Boolean(this._config.backdrop),
                        isAnimated: this._isAnimated()
                    })
                }
                _initializeFocusTrap() {
                    return new Re({
                        trapElement: this._element
                    })
                }
                _showElement(t) {
                    document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
                    const e = at.findOne(".modal-body", this._dialog);
                    e && (e.scrollTop = 0), S(this._element), this._element.classList.add(li);
                    this._queueCallback((() => {
                        this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, J.trigger(this._element, ei, {
                            relatedTarget: t
                        })
                    }), this._dialog, this._isAnimated())
                }
                _addEventListeners() {
                    J.on(this._element, oi, (t => {
                        "Escape" === t.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition())
                    })), J.on(window, ii, (() => {
                        this._isShown && !this._isTransitioning && this._adjustDialog()
                    })), J.on(this._element, ni, (t => {
                        J.one(this._element, si, (e => {
                            this._element === t.target && this._element === e.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition())
                        }))
                    }))
                }
                _hideModal() {
                    this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide((() => {
                        document.body.classList.remove(ai), this._resetAdjustments(), this._scrollBar.reset(), J.trigger(this._element, Je)
                    }))
                }
                _isAnimated() {
                    return this._element.classList.contains("fade")
                }
                _triggerBackdropTransition() {
                    if (J.trigger(this._element, Ge).defaultPrevented) return;
                    const t = this._element.scrollHeight > document.documentElement.clientHeight,
                        e = this._element.style.overflowY;
                    "hidden" === e || this._element.classList.contains(ci) || (t || (this._element.style.overflowY = "hidden"), this._element.classList.add(ci), this._queueCallback((() => {
                        this._element.classList.remove(ci), this._queueCallback((() => {
                            this._element.style.overflowY = e
                        }), this._dialog)
                    }), this._dialog), this._element.focus())
                }
                _adjustDialog() {
                    const t = this._element.scrollHeight > document.documentElement.clientHeight,
                        e = this._scrollBar.getWidth(),
                        i = e > 0;
                    if (i && !t) {
                        const t = O() ? "paddingLeft" : "paddingRight";
                        this._element.style[t] = `${e}px`
                    }
                    if (!i && t) {
                        const t = O() ? "paddingRight" : "paddingLeft";
                        this._element.style[t] = `${e}px`
                    }
                }
                _resetAdjustments() {
                    this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
                }
                static jQueryInterface(t, e) {
                    return this.each((function() {
                        const i = ui.getOrCreateInstance(this, t);
                        if ("string" == typeof t) {
                            if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
                            i[t](e)
                        }
                    }))
                }
            }
            J.on(document, ri, '[data-bs-toggle="modal"]', (function(t) {
                const e = at.getElementFromSelector(this);
                ["A", "AREA"].includes(this.tagName) && t.preventDefault(), J.one(e, ti, (t => {
                    t.defaultPrevented || J.one(e, Je, (() => {
                        k(this) && this.focus()
                    }))
                }));
                const i = at.findOne(".modal.show");
                i && ui.getInstance(i).hide();
                ui.getOrCreateInstance(e).toggle(this)
            })), lt(ui), M(ui);
            const _i = ".bs.offcanvas",
                fi = ".data-api",
                gi = `load${_i}${fi}`,
                mi = "show",
                pi = "showing",
                bi = "hiding",
                vi = ".offcanvas.show",
                yi = `show${_i}`,
                wi = `shown${_i}`,
                Ai = `hide${_i}`,
                Ci = `hidePrevented${_i}`,
                Ei = `hidden${_i}`,
                Ti = `resize${_i}`,
                ki = `click${_i}${fi}`,
                Li = `keydown.dismiss${_i}`,
                $i = {
                    backdrop: !0,
                    keyboard: !0,
                    scroll: !1
                },
                Di = {
                    backdrop: "(boolean|string)",
                    keyboard: "boolean",
                    scroll: "boolean"
                };
            class Si extends ot {
                constructor(t, e) {
                    super(t, e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners()
                }
                static get Default() {
                    return $i
                }
                static get DefaultType() {
                    return Di
                }
                static get NAME() {
                    return "offcanvas"
                }
                toggle(t) {
                    return this._isShown ? this.hide() : this.show(t)
                }
                show(t) {
                    if (this._isShown) return;
                    if (J.trigger(this._element, yi, {
                            relatedTarget: t
                        }).defaultPrevented) return;
                    this._isShown = !0, this._backdrop.show(), this._config.scroll || (new Xe).hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(pi);
                    this._queueCallback((() => {
                        this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add(mi), this._element.classList.remove(pi), J.trigger(this._element, wi, {
                            relatedTarget: t
                        })
                    }), this._element, !0)
                }
                hide() {
                    if (!this._isShown) return;
                    if (J.trigger(this._element, Ai).defaultPrevented) return;
                    this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(bi), this._backdrop.hide();
                    this._queueCallback((() => {
                        this._element.classList.remove(mi, bi), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || (new Xe).reset(), J.trigger(this._element, Ei)
                    }), this._element, !0)
                }
                dispose() {
                    this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
                }
                _initializeBackDrop() {
                    const t = Boolean(this._config.backdrop);
                    return new Fe({
                        className: "offcanvas-backdrop",
                        isVisible: t,
                        isAnimated: !0,
                        rootElement: this._element.parentNode,
                        clickCallback: t ? () => {
                            "static" !== this._config.backdrop ? this.hide() : J.trigger(this._element, Ci)
                        } : null
                    })
                }
                _initializeFocusTrap() {
                    return new Re({
                        trapElement: this._element
                    })
                }
                _addEventListeners() {
                    J.on(this._element, Li, (t => {
                        "Escape" === t.key && (this._config.keyboard ? this.hide() : J.trigger(this._element, Ci))
                    }))
                }
                static jQueryInterface(t) {
                    return this.each((function() {
                        const e = Si.getOrCreateInstance(this, t);
                        if ("string" == typeof t) {
                            if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                            e[t](this)
                        }
                    }))
                }
            }
            J.on(document, ki, '[data-bs-toggle="offcanvas"]', (function(t) {
                const e = at.getElementFromSelector(this);
                if (["A", "AREA"].includes(this.tagName) && t.preventDefault(), L(this)) return;
                J.one(e, Ei, (() => {
                    k(this) && this.focus()
                }));
                const i = at.findOne(vi);
                i && i !== e && Si.getInstance(i).hide();
                Si.getOrCreateInstance(e).toggle(this)
            })), J.on(window, gi, (() => {
                for (const t of at.find(vi)) Si.getOrCreateInstance(t).show()
            })), J.on(window, Ti, (() => {
                for (const t of at.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(t).position && Si.getOrCreateInstance(t).hide()
            })), lt(Si), M(Si);
            const Ni = {
                    "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
                    a: ["target", "href", "title", "rel"],
                    area: [],
                    b: [],
                    br: [],
                    col: [],
                    code: [],
                    div: [],
                    em: [],
                    hr: [],
                    h1: [],
                    h2: [],
                    h3: [],
                    h4: [],
                    h5: [],
                    h6: [],
                    i: [],
                    img: ["src", "srcset", "alt", "title", "width", "height"],
                    li: [],
                    ol: [],
                    p: [],
                    pre: [],
                    s: [],
                    small: [],
                    span: [],
                    sub: [],
                    sup: [],
                    strong: [],
                    u: [],
                    ul: []
                },
                Ii = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
                Oi = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i,
                Mi = (t, e) => {
                    const i = t.nodeName.toLowerCase();
                    return e.includes(i) ? !Ii.has(i) || Boolean(Oi.test(t.nodeValue)) : e.filter((t => t instanceof RegExp)).some((t => t.test(i)))
                };
            const xi = {
                    allowList: Ni,
                    content: {},
                    extraClass: "",
                    html: !1,
                    sanitize: !0,
                    sanitizeFn: null,
                    template: "<div></div>"
                },
                Pi = {
                    allowList: "object",
                    content: "object",
                    extraClass: "(string|function)",
                    html: "boolean",
                    sanitize: "boolean",
                    sanitizeFn: "(null|function)",
                    template: "string"
                },
                Fi = {
                    entry: "(string|element|function|null)",
                    selector: "(string|element)"
                };
            class zi extends nt {
                constructor(t) {
                    super(), this._config = this._getConfig(t)
                }
                static get Default() {
                    return xi
                }
                static get DefaultType() {
                    return Pi
                }
                static get NAME() {
                    return "TemplateFactory"
                }
                getContent() {
                    return Object.values(this._config.content).map((t => this._resolvePossibleFunction(t))).filter(Boolean)
                }
                hasContent() {
                    return this.getContent().length > 0
                }
                changeContent(t) {
                    return this._checkContent(t), this._config.content = {
                        ...this._config.content,
                        ...t
                    }, this
                }
                toHtml() {
                    const t = document.createElement("div");
                    t.innerHTML = this._maybeSanitize(this._config.template);
                    for (const [e, i] of Object.entries(this._config.content)) this._setContent(t, i, e);
                    const e = t.children[0],
                        i = this._resolvePossibleFunction(this._config.extraClass);
                    return i && e.classList.add(...i.split(" ")), e
                }
                _typeCheckConfig(t) {
                    super._typeCheckConfig(t), this._checkContent(t.content)
                }
                _checkContent(t) {
                    for (const [e, i] of Object.entries(t)) super._typeCheckConfig({
                        selector: e,
                        entry: i
                    }, Fi)
                }
                _setContent(t, e, i) {
                    const s = at.findOne(i, t);
                    s && ((e = this._resolvePossibleFunction(e)) ? E(e) ? this._putElementInTemplate(T(e), s) : this._config.html ? s.innerHTML = this._maybeSanitize(e) : s.textContent = e : s.remove())
                }
                _maybeSanitize(t) {
                    return this._config.sanitize ? function(t, e, i) {
                        if (!t.length) return t;
                        if (i && "function" == typeof i) return i(t);
                        const s = (new window.DOMParser).parseFromString(t, "text/html"),
                            n = [].concat(...s.body.querySelectorAll("*"));
                        for (const t of n) {
                            const i = t.nodeName.toLowerCase();
                            if (!Object.keys(e).includes(i)) {
                                t.remove();
                                continue
                            }
                            const s = [].concat(...t.attributes),
                                n = [].concat(e["*"] || [], e[i] || []);
                            for (const e of s) Mi(e, n) || t.removeAttribute(e.nodeName)
                        }
                        return s.body.innerHTML
                    }(t, this._config.allowList, this._config.sanitizeFn) : t
                }
                _resolvePossibleFunction(t) {
                    return x(t, [this])
                }
                _putElementInTemplate(t, e) {
                    if (this._config.html) return e.innerHTML = "", void e.append(t);
                    e.textContent = t.textContent
                }
            }
            const ji = new Set(["sanitize", "allowList", "sanitizeFn"]),
                Hi = "fade",
                Bi = "show",
                Wi = ".modal",
                qi = "hide.bs.modal",
                Ri = "hover",
                Vi = "focus",
                Ki = {
                    AUTO: "auto",
                    TOP: "top",
                    RIGHT: O() ? "left" : "right",
                    BOTTOM: "bottom",
                    LEFT: O() ? "right" : "left"
                },
                Zi = {
                    allowList: Ni,
                    animation: !0,
                    boundary: "clippingParents",
                    container: !1,
                    customClass: "",
                    delay: 0,
                    fallbackPlacements: ["top", "right", "bottom", "left"],
                    html: !1,
                    offset: [0, 6],
                    placement: "top",
                    popperConfig: null,
                    sanitize: !0,
                    sanitizeFn: null,
                    selector: !1,
                    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
                    title: "",
                    trigger: "hover focus"
                },
                Qi = {
                    allowList: "object",
                    animation: "boolean",
                    boundary: "(string|element)",
                    container: "(string|element|boolean)",
                    customClass: "(string|function)",
                    delay: "(number|object)",
                    fallbackPlacements: "array",
                    html: "boolean",
                    offset: "(array|string|function)",
                    placement: "(string|function)",
                    popperConfig: "(null|object|function)",
                    sanitize: "boolean",
                    sanitizeFn: "(null|function)",
                    selector: "(string|boolean)",
                    template: "string",
                    title: "(string|element|function)",
                    trigger: "string"
                };
            class Xi extends ot {
                constructor(t, e) {
                    if (void 0 === s) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
                    super(t, e), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle()
                }
                static get Default() {
                    return Zi
                }
                static get DefaultType() {
                    return Qi
                }
                static get NAME() {
                    return "tooltip"
                }
                enable() {
                    this._isEnabled = !0
                }
                disable() {
                    this._isEnabled = !1
                }
                toggleEnabled() {
                    this._isEnabled = !this._isEnabled
                }
                toggle() {
                    this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click, this._isShown() ? this._leave() : this._enter())
                }
                dispose() {
                    clearTimeout(this._timeout), J.off(this._element.closest(Wi), qi, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose()
                }
                show() {
                    if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
                    if (!this._isWithContent() || !this._isEnabled) return;
                    const t = J.trigger(this._element, this.constructor.eventName("show")),
                        e = ($(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
                    if (t.defaultPrevented || !e) return;
                    this._disposePopper();
                    const i = this._getTipElement();
                    this._element.setAttribute("aria-describedby", i.getAttribute("id"));
                    const {
                        container: s
                    } = this._config;
                    if (this._element.ownerDocument.documentElement.contains(this.tip) || (s.append(i), J.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(i), i.classList.add(Bi), "ontouchstart" in document.documentElement)
                        for (const t of [].concat(...document.body.children)) J.on(t, "mouseover", D);
                    this._queueCallback((() => {
                        J.trigger(this._element, this.constructor.eventName("shown")), !1 === this._isHovered && this._leave(), this._isHovered = !1
                    }), this.tip, this._isAnimated())
                }
                hide() {
                    if (!this._isShown()) return;
                    if (J.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) return;
                    if (this._getTipElement().classList.remove(Bi), "ontouchstart" in document.documentElement)
                        for (const t of [].concat(...document.body.children)) J.off(t, "mouseover", D);
                    this._activeTrigger.click = !1, this._activeTrigger[Vi] = !1, this._activeTrigger[Ri] = !1, this._isHovered = null;
                    this._queueCallback((() => {
                        this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), J.trigger(this._element, this.constructor.eventName("hidden")))
                    }), this.tip, this._isAnimated())
                }
                update() {
                    this._popper && this._popper.update()
                }
                _isWithContent() {
                    return Boolean(this._getTitle())
                }
                _getTipElement() {
                    return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip
                }
                _createTipElement(t) {
                    const e = this._getTemplateFactory(t).toHtml();
                    if (!e) return null;
                    e.classList.remove(Hi, Bi), e.classList.add(`bs-${this.constructor.NAME}-auto`);
                    const i = (t => {
                        do {
                            t += Math.floor(1e6 * Math.random())
                        } while (document.getElementById(t));
                        return t
                    })(this.constructor.NAME).toString();
                    return e.setAttribute("id", i), this._isAnimated() && e.classList.add(Hi), e
                }
                setContent(t) {
                    this._newContent = t, this._isShown() && (this._disposePopper(), this.show())
                }
                _getTemplateFactory(t) {
                    return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new zi({
                        ...this._config,
                        content: t,
                        extraClass: this._resolvePossibleFunction(this._config.customClass)
                    }), this._templateFactory
                }
                _getContentForTemplate() {
                    return {
                        ".tooltip-inner": this._getTitle()
                    }
                }
                _getTitle() {
                    return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title")
                }
                _initializeOnDelegatedTarget(t) {
                    return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig())
                }
                _isAnimated() {
                    return this._config.animation || this.tip && this.tip.classList.contains(Hi)
                }
                _isShown() {
                    return this.tip && this.tip.classList.contains(Bi)
                }
                _createPopper(t) {
                    const e = x(this._config.placement, [this, t, this._element]),
                        i = Ki[e.toUpperCase()];
                    return m.fi(this._element, t, this._getPopperConfig(i))
                }
                _getOffset() {
                    const {
                        offset: t
                    } = this._config;
                    return "string" == typeof t ? t.split(",").map((t => Number.parseInt(t, 10))) : "function" == typeof t ? e => t(e, this._element) : t
                }
                _resolvePossibleFunction(t) {
                    return x(t, [this._element])
                }
                _getPopperConfig(t) {
                    const e = {
                        placement: t,
                        modifiers: [{
                            name: "flip",
                            options: {
                                fallbackPlacements: this._config.fallbackPlacements
                            }
                        }, {
                            name: "offset",
                            options: {
                                offset: this._getOffset()
                            }
                        }, {
                            name: "preventOverflow",
                            options: {
                                boundary: this._config.boundary
                            }
                        }, {
                            name: "arrow",
                            options: {
                                element: `.${this.constructor.NAME}-arrow`
                            }
                        }, {
                            name: "preSetPlacement",
                            enabled: !0,
                            phase: "beforeMain",
                            fn: t => {
                                this._getTipElement().setAttribute("data-popper-placement", t.state.placement)
                            }
                        }]
                    };
                    return {
                        ...e,
                        ...x(this._config.popperConfig, [e])
                    }
                }
                _setListeners() {
                    const t = this._config.trigger.split(" ");
                    for (const e of t)
                        if ("click" === e) J.on(this._element, this.constructor.eventName("click"), this._config.selector, (t => {
                            this._initializeOnDelegatedTarget(t).toggle()
                        }));
                        else if ("manual" !== e) {
                        const t = e === Ri ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"),
                            i = e === Ri ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
                        J.on(this._element, t, this._config.selector, (t => {
                            const e = this._initializeOnDelegatedTarget(t);
                            e._activeTrigger["focusin" === t.type ? Vi : Ri] = !0, e._enter()
                        })), J.on(this._element, i, this._config.selector, (t => {
                            const e = this._initializeOnDelegatedTarget(t);
                            e._activeTrigger["focusout" === t.type ? Vi : Ri] = e._element.contains(t.relatedTarget), e._leave()
                        }))
                    }
                    this._hideModalHandler = () => {
                        this._element && this.hide()
                    }, J.on(this._element.closest(Wi), qi, this._hideModalHandler)
                }
                _fixTitle() {
                    const t = this._element.getAttribute("title");
                    t && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t), this._element.setAttribute("data-bs-original-title", t), this._element.removeAttribute("title"))
                }
                _enter() {
                    this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout((() => {
                        this._isHovered && this.show()
                    }), this._config.delay.show))
                }
                _leave() {
                    this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout((() => {
                        this._isHovered || this.hide()
                    }), this._config.delay.hide))
                }
                _setTimeout(t, e) {
                    clearTimeout(this._timeout), this._timeout = setTimeout(t, e)
                }
                _isWithActiveTrigger() {
                    return Object.values(this._activeTrigger).includes(!0)
                }
                _getConfig(t) {
                    const e = st.getDataAttributes(this._element);
                    for (const t of Object.keys(e)) ji.has(t) && delete e[t];
                    return t = {
                        ...e,
                        ..."object" == typeof t && t ? t : {}
                    }, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
                }
                _configAfterMerge(t) {
                    return t.container = !1 === t.container ? document.body : T(t.container), "number" == typeof t.delay && (t.delay = {
                        show: t.delay,
                        hide: t.delay
                    }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), t
                }
                _getDelegateConfig() {
                    const t = {};
                    for (const [e, i] of Object.entries(this._config)) this.constructor.Default[e] !== i && (t[e] = i);
                    return t.selector = !1, t.trigger = "manual", t
                }
                _disposePopper() {
                    this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null)
                }
                static jQueryInterface(t) {
                    return this.each((function() {
                        const e = Xi.getOrCreateInstance(this, t);
                        if ("string" == typeof t) {
                            if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                            e[t]()
                        }
                    }))
                }
            }
            M(Xi);
            const Yi = {
                    ...Xi.Default,
                    content: "",
                    offset: [0, 8],
                    placement: "right",
                    template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
                    trigger: "click"
                },
                Ui = {
                    ...Xi.DefaultType,
                    content: "(null|string|element|function)"
                };
            class Gi extends Xi {
                static get Default() {
                    return Yi
                }
                static get DefaultType() {
                    return Ui
                }
                static get NAME() {
                    return "popover"
                }
                _isWithContent() {
                    return this._getTitle() || this._getContent()
                }
                _getContentForTemplate() {
                    return {
                        ".popover-header": this._getTitle(),
                        ".popover-body": this._getContent()
                    }
                }
                _getContent() {
                    return this._resolvePossibleFunction(this._config.content)
                }
                static jQueryInterface(t) {
                    return this.each((function() {
                        const e = Gi.getOrCreateInstance(this, t);
                        if ("string" == typeof t) {
                            if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                            e[t]()
                        }
                    }))
                }
            }
            M(Gi);
            const Ji = ".bs.scrollspy",
                ts = `activate${Ji}`,
                es = `click${Ji}`,
                is = `load${Ji}.data-api`,
                ss = "active",
                ns = "[href]",
                os = ".nav-link",
                rs = `${os}, .nav-item > ${os}, .list-group-item`,
                as = {
                    offset: null,
                    rootMargin: "0px 0px -25%",
                    smoothScroll: !1,
                    target: null,
                    threshold: [.1, .5, 1]
                },
                ls = {
                    offset: "(number|null)",
                    rootMargin: "string",
                    smoothScroll: "boolean",
                    target: "element",
                    threshold: "array"
                };
            class cs extends ot {
                constructor(t, e) {
                    super(t, e), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = {
                        visibleEntryTop: 0,
                        parentScrollTop: 0
                    }, this.refresh()
                }
                static get Default() {
                    return as
                }
                static get DefaultType() {
                    return ls
                }
                static get NAME() {
                    return "scrollspy"
                }
                refresh() {
                    this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
                    for (const t of this._observableSections.values()) this._observer.observe(t)
                }
                dispose() {
                    this._observer.disconnect(), super.dispose()
                }
                _configAfterMerge(t) {
                    return t.target = T(t.target) || document.body, t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin, "string" == typeof t.threshold && (t.threshold = t.threshold.split(",").map((t => Number.parseFloat(t)))), t
                }
                _maybeEnableSmoothScroll() {
                    this._config.smoothScroll && (J.off(this._config.target, es), J.on(this._config.target, es, ns, (t => {
                        const e = this._observableSections.get(t.target.hash);
                        if (e) {
                            t.preventDefault();
                            const i = this._rootElement || window,
                                s = e.offsetTop - this._element.offsetTop;
                            if (i.scrollTo) return void i.scrollTo({
                                top: s,
                                behavior: "smooth"
                            });
                            i.scrollTop = s
                        }
                    })))
                }
                _getNewObserver() {
                    const t = {
                        root: this._rootElement,
                        threshold: this._config.threshold,
                        rootMargin: this._config.rootMargin
                    };
                    return new IntersectionObserver((t => this._observerCallback(t)), t)
                }
                _observerCallback(t) {
                    const e = t => this._targetLinks.get(`#${t.target.id}`),
                        i = t => {
                            this._previousScrollData.visibleEntryTop = t.target.offsetTop, this._process(e(t))
                        },
                        s = (this._rootElement || document.documentElement).scrollTop,
                        n = s >= this._previousScrollData.parentScrollTop;
                    this._previousScrollData.parentScrollTop = s;
                    for (const o of t) {
                        if (!o.isIntersecting) {
                            this._activeTarget = null, this._clearActiveClass(e(o));
                            continue
                        }
                        const t = o.target.offsetTop >= this._previousScrollData.visibleEntryTop;
                        if (n && t) {
                            if (i(o), !s) return
                        } else n || t || i(o)
                    }
                }
                _initializeTargetsAndObservables() {
                    this._targetLinks = new Map, this._observableSections = new Map;
                    const t = at.find(ns, this._config.target);
                    for (const e of t) {
                        if (!e.hash || L(e)) continue;
                        const t = at.findOne(decodeURI(e.hash), this._element);
                        k(t) && (this._targetLinks.set(decodeURI(e.hash), e), this._observableSections.set(e.hash, t))
                    }
                }
                _process(t) {
                    this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add(ss), this._activateParents(t), J.trigger(this._element, ts, {
                        relatedTarget: t
                    }))
                }
                _activateParents(t) {
                    if (t.classList.contains("dropdown-item")) at.findOne(".dropdown-toggle", t.closest(".dropdown")).classList.add(ss);
                    else
                        for (const e of at.parents(t, ".nav, .list-group"))
                            for (const t of at.prev(e, rs)) t.classList.add(ss)
                }
                _clearActiveClass(t) {
                    t.classList.remove(ss);
                    const e = at.find(`${ns}.${ss}`, t);
                    for (const t of e) t.classList.remove(ss)
                }
                static jQueryInterface(t) {
                    return this.each((function() {
                        const e = cs.getOrCreateInstance(this, t);
                        if ("string" == typeof t) {
                            if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                            e[t]()
                        }
                    }))
                }
            }
            J.on(window, is, (() => {
                for (const t of at.find('[data-bs-spy="scroll"]')) cs.getOrCreateInstance(t)
            })), M(cs);
            const hs = ".bs.tab",
                ds = `hide${hs}`,
                us = `hidden${hs}`,
                _s = `show${hs}`,
                fs = `shown${hs}`,
                gs = `click${hs}`,
                ms = `keydown${hs}`,
                ps = `load${hs}`,
                bs = "ArrowLeft",
                vs = "ArrowRight",
                ys = "ArrowUp",
                ws = "ArrowDown",
                As = "Home",
                Cs = "End",
                Es = "active",
                Ts = "fade",
                ks = "show",
                Ls = ".dropdown-toggle",
                $s = `:not(${Ls})`,
                Ds = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
                Ss = `${`.nav-link${$s}, .list-group-item${$s}, [role="tab"]${$s}`}, ${Ds}`,
                Ns = `.${Es}[data-bs-toggle="tab"], .${Es}[data-bs-toggle="pill"], .${Es}[data-bs-toggle="list"]`;
            class Is extends ot {
                constructor(t) {
                    super(t), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), J.on(this._element, ms, (t => this._keydown(t))))
                }
                static get NAME() {
                    return "tab"
                }
                show() {
                    const t = this._element;
                    if (this._elemIsActive(t)) return;
                    const e = this._getActiveElem(),
                        i = e ? J.trigger(e, ds, {
                            relatedTarget: t
                        }) : null;
                    J.trigger(t, _s, {
                        relatedTarget: e
                    }).defaultPrevented || i && i.defaultPrevented || (this._deactivate(e, t), this._activate(t, e))
                }
                _activate(t, e) {
                    if (!t) return;
                    t.classList.add(Es), this._activate(at.getElementFromSelector(t));
                    this._queueCallback((() => {
                        "tab" === t.getAttribute("role") ? (t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), J.trigger(t, fs, {
                            relatedTarget: e
                        })) : t.classList.add(ks)
                    }), t, t.classList.contains(Ts))
                }
                _deactivate(t, e) {
                    if (!t) return;
                    t.classList.remove(Es), t.blur(), this._deactivate(at.getElementFromSelector(t));
                    this._queueCallback((() => {
                        "tab" === t.getAttribute("role") ? (t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), J.trigger(t, us, {
                            relatedTarget: e
                        })) : t.classList.remove(ks)
                    }), t, t.classList.contains(Ts))
                }
                _keydown(t) {
                    if (![bs, vs, ys, ws, As, Cs].includes(t.key)) return;
                    t.stopPropagation(), t.preventDefault();
                    const e = this._getChildren().filter((t => !L(t)));
                    let i;
                    if ([As, Cs].includes(t.key)) i = e[t.key === As ? 0 : e.length - 1];
                    else {
                        const s = [vs, ws].includes(t.key);
                        i = F(e, t.target, s, !0)
                    }
                    i && (i.focus({
                        preventScroll: !0
                    }), Is.getOrCreateInstance(i).show())
                }
                _getChildren() {
                    return at.find(Ss, this._parent)
                }
                _getActiveElem() {
                    return this._getChildren().find((t => this._elemIsActive(t))) || null
                }
                _setInitialAttributes(t, e) {
                    this._setAttributeIfNotExists(t, "role", "tablist");
                    for (const t of e) this._setInitialAttributesOnChild(t)
                }
                _setInitialAttributesOnChild(t) {
                    t = this._getInnerElement(t);
                    const e = this._elemIsActive(t),
                        i = this._getOuterElement(t);
                    t.setAttribute("aria-selected", e), i !== t && this._setAttributeIfNotExists(i, "role", "presentation"), e || t.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t, "role", "tab"), this._setInitialAttributesOnTargetPanel(t)
                }
                _setInitialAttributesOnTargetPanel(t) {
                    const e = at.getElementFromSelector(t);
                    e && (this._setAttributeIfNotExists(e, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(e, "aria-labelledby", `${t.id}`))
                }
                _toggleDropDown(t, e) {
                    const i = this._getOuterElement(t);
                    if (!i.classList.contains("dropdown")) return;
                    const s = (t, s) => {
                        const n = at.findOne(t, i);
                        n && n.classList.toggle(s, e)
                    };
                    s(Ls, Es), s(".dropdown-menu", ks), i.setAttribute("aria-expanded", e)
                }
                _setAttributeIfNotExists(t, e, i) {
                    t.hasAttribute(e) || t.setAttribute(e, i)
                }
                _elemIsActive(t) {
                    return t.classList.contains(Es)
                }
                _getInnerElement(t) {
                    return t.matches(Ss) ? t : at.findOne(Ss, t)
                }
                _getOuterElement(t) {
                    return t.closest(".nav-item, .list-group-item") || t
                }
                static jQueryInterface(t) {
                    return this.each((function() {
                        const e = Is.getOrCreateInstance(this);
                        if ("string" == typeof t) {
                            if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                            e[t]()
                        }
                    }))
                }
            }
            J.on(document, gs, Ds, (function(t) {
                ["A", "AREA"].includes(this.tagName) && t.preventDefault(), L(this) || Is.getOrCreateInstance(this).show()
            })), J.on(window, ps, (() => {
                for (const t of at.find(Ns)) Is.getOrCreateInstance(t)
            })), M(Is);
            const Os = ".bs.toast",
                Ms = `mouseover${Os}`,
                xs = `mouseout${Os}`,
                Ps = `focusin${Os}`,
                Fs = `focusout${Os}`,
                zs = `hide${Os}`,
                js = `hidden${Os}`,
                Hs = `show${Os}`,
                Bs = `shown${Os}`,
                Ws = "hide",
                qs = "show",
                Rs = "showing",
                Vs = {
                    animation: "boolean",
                    autohide: "boolean",
                    delay: "number"
                },
                Ks = {
                    animation: !0,
                    autohide: !0,
                    delay: 5e3
                };
            class Zs extends ot {
                constructor(t, e) {
                    super(t, e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners()
                }
                static get Default() {
                    return Ks
                }
                static get DefaultType() {
                    return Vs
                }
                static get NAME() {
                    return "toast"
                }
                show() {
                    if (J.trigger(this._element, Hs).defaultPrevented) return;
                    this._clearTimeout(), this._config.animation && this._element.classList.add("fade");
                    this._element.classList.remove(Ws), S(this._element), this._element.classList.add(qs, Rs), this._queueCallback((() => {
                        this._element.classList.remove(Rs), J.trigger(this._element, Bs), this._maybeScheduleHide()
                    }), this._element, this._config.animation)
                }
                hide() {
                    if (!this.isShown()) return;
                    if (J.trigger(this._element, zs).defaultPrevented) return;
                    this._element.classList.add(Rs), this._queueCallback((() => {
                        this._element.classList.add(Ws), this._element.classList.remove(Rs, qs), J.trigger(this._element, js)
                    }), this._element, this._config.animation)
                }
                dispose() {
                    this._clearTimeout(), this.isShown() && this._element.classList.remove(qs), super.dispose()
                }
                isShown() {
                    return this._element.classList.contains(qs)
                }
                _maybeScheduleHide() {
                    this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout((() => {
                        this.hide()
                    }), this._config.delay)))
                }
                _onInteraction(t, e) {
                    switch (t.type) {
                        case "mouseover":
                        case "mouseout":
                            this._hasMouseInteraction = e;
                            break;
                        case "focusin":
                        case "focusout":
                            this._hasKeyboardInteraction = e
                    }
                    if (e) return void this._clearTimeout();
                    const i = t.relatedTarget;
                    this._element === i || this._element.contains(i) || this._maybeScheduleHide()
                }
                _setListeners() {
                    J.on(this._element, Ms, (t => this._onInteraction(t, !0))), J.on(this._element, xs, (t => this._onInteraction(t, !1))), J.on(this._element, Ps, (t => this._onInteraction(t, !0))), J.on(this._element, Fs, (t => this._onInteraction(t, !1)))
                }
                _clearTimeout() {
                    clearTimeout(this._timeout), this._timeout = null
                }
                static jQueryInterface(t) {
                    return this.each((function() {
                        const e = Zs.getOrCreateInstance(this, t);
                        if ("string" == typeof t) {
                            if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                            e[t](this)
                        }
                    }))
                }
            }
            lt(Zs), M(Zs)
        }
    }
]);
//# sourceMappingURL=226011a26f115c91bddbee904c702f5edde14817c832d8901bbe4bc9ac453e1b.js.map